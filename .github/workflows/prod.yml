name: Build and Deploy Salesforce Package

on:
  push:
    branches:
      - prod 

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest 
    steps:
      # 1. Get your code from the repository 
      - name: Check out repository
        uses: actions/checkout@v4

      # 2. Install the Salesforce CLI
      - name: Install Salesforce CLI
        uses: sfdx-actions/setup-sfdx@v1
  
      # 3. Authenticate to the Dev Hub (where packages are created)
      # Uses the SF_DEV_HUB_AUTH_URL secret you created
      - name: Authenticate to Dev Hub
        run: |
          echo "${{ secrets.SF_DEV_HUB_AUTH_URL }}" > ./devhub-auth.txt
          sf org login sfdx-url --sfdx-url-file ./devhub-auth.txt --set-default-dev-hub --alias devHub

      # 4. Authenticate to the Production Org (where package is installed)
      # Uses the SF_PROD_AUTH_URL secret
      - name: Authenticate to Production Org
        run: |
          echo "${{ secrets.SF_PROD_AUTH_URL }}" > ./prod-auth.txt
          sf org login sfdx-url --sfdx-url-file ./prod-auth.txt --alias prodOrg

      # 5. Create a new package version
      - name: Create New Package Version
        run: |
          echo "Attempting to create new version for package: serverobjectpackage"
          
          # 1. Run the command and store the STDOUT (which is only JSON) in OUTPUT.
          #    STDERR (warnings, logs) will print to the action log.
          #    We use '|| true' to let the script continue so we can parse the JSON.
          OUTPUT=$(sf package version create --package "serverobjectpackage" --installation-key "${{ secrets.PACKAGE_INSTALL_KEY }}" --wait 15 --json || true)

          echo "-----------------------------------------------------"
          echo "Full JSON output from sf package version create:"
          echo "$OUTPUT"
          echo "-----------------------------------------------------"

          # 2. Check the 'status' field in the JSON. This is the reliable way.
          STATUS_CODE=$(echo $OUTPUT | jq -r .status)
          
          if [ "$STATUS_CODE" != "0" ]; then
            echo "::error::Failed to create package version. The command returned a non-zero status."
            echo "Full JSON response was: $OUTPUT"
            exit 1 # Manually fail the job
          fi
          
          # 3. If we are here, it was a 100% success. Parse the ID.
          PACKAGE_VERSION_ID=$(echo $OUTPUT | jq -r .result.SubscriberPackageVersionId)
          
          if [ -z "$PACKAGE_VERSION_ID" ] || [ "$PACKAGE_VERSION_ID" == "null" ]; then
            echo "::error::Successfully ran command (status 0), but failed to parse Package Version ID from JSON."
            echo "JSON was: $OUTPUT"
            exit 1
          fi
          
          echo "New Package Version ID: $PACKAGE_VERSION_ID"
          echo "PACKAGE_VERSION_ID=$PACKAGE_VERSION_ID" >> $GITHUB_ENV

      # 6. Promote the new version to "Released"
      # This is best practice before installing in production
      - name: Promote Package Version
        run: |
          echo "Promoting package version: ${{ env.PACKAGE_VERSION_ID }}"
          sf package version promote --package "${{ env.PACKAGE_VERSION_ID }}" --no-prompt

      # 7. Install the new version into Production
      # This is the final deployment step
      - name: Install Package in Production
        run: |
          echo "Installing package version: ${{ env.PACKAGE_VERSION_ID }} into prodOrg"
          sf package install --package "${{ env.PACKAGE_VERSION_ID }}" --target-org prodOrg --installation-key "${{ secrets.PACKAGE_INSTALL_KEY }}" --wait 10 --publish-wait 10