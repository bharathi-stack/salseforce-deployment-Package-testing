# name: Build and Deploy Salesforce Package

# on:
#   push:
#     branches:
#       - prod 

# jobs:
#   build-and-deploy:
#     runs-on: ubuntu-latest 
#     steps:
#       # 1. Get your code from the repository 
#       - name: Check out repository
#         uses: actions/checkout@v4

#       # 2. Install the Salesforce CLI
#       - name: Install Salesforce CLI
#         uses: sfdx-actions/setup-sfdx@v1
  
#       # 3. Authenticate to the Dev Hub (where packages are created)
#       # Uses the SF_DEV_HUB_AUTH_URL secret you created
#       - name: Authenticate to Dev Hub
#         run: |
#           echo "${{ secrets.SF_DEV_HUB_AUTH_URL }}" > ./devhub-auth.txt
#           sf org login sfdx-url --sfdx-url-file ./devhub-auth.txt --set-default-dev-hub --alias devHub

#       # 4. Authenticate to the Production Org (where package is installed)
#       # Uses the SF_PROD_AUTH_URL secret
#       - name: Authenticate to Production Org
#         run: |
#           echo "${{ secrets.SF_PROD_AUTH_URL }}" > ./prod-auth.txt
#           sf org login sfdx-url --sfdx-url-file ./prod-auth.txt --alias prodOrg

#       # 5. Create a new package version
#       - name: Create New Package Version
#         run: |
#           echo "Attempting to create new version for package: serverobjectpackage"
          
#           # We've added the --code-coverage flag here.
#           # This tells Salesforce to run all Apex tests and check for 75% coverage.
#           OUTPUT=$(sf package version create --package "serverobjectpackage" --installation-key "${{ secrets.PACKAGE_INSTALL_KEY }}" --wait 15 --json --code-coverage || true)

#           echo "-----------------------------------------------------"
#           echo "Full JSON output from sf package version create:"
#           echo "$OUTPUT"
#           echo "-----------------------------------------------------"

#           # 2. Check the 'status' field in the JSON. This is the reliable way.
#           STATUS_CODE=$(echo $OUTPUT | jq -r .status)
          
#           if [ "$STATUS_CODE" != "0" ]; then
#             echo "::error::Failed to create package version. The command returned a non-zero status."
#             echo "Full JSON response was: $OUTPUT"
#             exit 1 # Manually fail the job
#           fi
          
#           # 3. If we are here, it was a 100% success. Parse the ID.
#           PACKAGE_VERSION_ID=$(echo $OUTPUT | jq -r .result.SubscriberPackageVersionId)
          
#           if [ -z "$PACKAGE_VERSION_ID" ] || [ "$PACKAGE_VERSION_ID" == "null" ]; then
#             echo "::error::Successfully ran command (status 0), but failed to parse Package Version ID from JSON."
#             echo "JSON was: $OUTPUT"
#             exit 1
#           fi
          
#           echo "New Package Version ID: $PACKAGE_VERSION_ID"
#           echo "PACKAGE_VERSION_ID=$PACKAGE_VERSION_ID" >> $GITHUB_ENV

#       # 6. Promote the new version to "Released"
#       # This is best practice before installing in production
#       - name: Promote Package Version
#         run: |
#           echo "Promoting package version: ${{ env.PACKAGE_VERSION_ID }}"
#           sf package version promote --package "${{ env.PACKAGE_VERSION_ID }}" --no-prompt

#       # 7. Install the new version into Production
#       # This is the final deployment step
#       - name: Install Package in Production
#         run: |
#           echo "Installing package version: ${{ env.PACKAGE_VERSION_ID }} into prodOrg"
#           sf package install --package "${{ env.PACKAGE_VERSION_ID }}" --target-org prodOrg --installation-key "${{ secrets.PACKAGE_INSTALL_KEY }}" --wait 10 --publish-wait 10





























name: Build and Deploy Salesforce Package

on:
  push:
    branches:
      - prod 

jobs:
  # JOB 1: Creates and Promotes the package
  build_and_promote:
    runs-on: ubuntu-latest
    
    # This section 'outputs' makes the Package ID available to other jobs
    outputs:
      package_version_id: ${{ steps.create_version.outputs.package_id }}

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Install Salesforce CLI
        uses: sfdx-actions/setup-sfdx@v1
  
      - name: Authenticate to Dev Hub
        run: |
          echo "${{ secrets.SF_DEV_HUB_AUTH_URL }}" > ./devhub-auth.txt
          sf org login sfdx-url --sfdx-url-file ./devhub-auth.txt --set-default-dev-hub --alias devHub

      # This step now has an 'id' so we can reference its 'outputs'
      - name: Create New Package Version
        id: create_version 
        run: |
          echo "Attempting to create new version for package: serverobjectpackage"
          OUTPUT=$(sf package version create --package "serverobjectpackage" --installation-key "${{ secrets.PACKAGE_INSTALL_KEY }}" --wait 15 --json --code-coverage || true)
          echo "-----------------------------------------------------"
          echo "Full JSON output from sf package version create:"
          echo "$OUTPUT"
          echo "-----------------------------------------------------"

          STATUS_CODE=$(echo $OUTPUT | jq -r .status)
          if [ "$STATUS_CODE" != "0" ]; then
            echo "::error::Failed to create package version. The command returned a non-zero status."
            echo "Full JSON response was: $OUTPUT"
            exit 1 # Manually fail the job
          fi
          
          PACKAGE_VERSION_ID=$(echo $OUTPUT | jq -r .result.SubscriberPackageVersionId)
          if [ -z "$PACKAGE_VERSION_ID" ] || [ "$PACKAGE_VERSION_ID" == "null" ]; then
            echo "::error::Successfully ran command (status 0), but failed to parse Package Version ID from JSON."
            echo "JSON was: $OUTPUT"
            exit 1
          fi
          
          echo "New Package Version ID: $PACKAGE_VERSION_ID"
          
          # This line makes the ID available to the 'outputs' section at the top of the job
          echo "package_id=$PACKAGE_VERSION_ID" >> $GITHUB_OUTPUT
          
          # This line makes the ID available to the *next step in this job*
          echo "PACKAGE_VERSION_ID=$PACKAGE_VERSION_ID" >> $GITHUB_ENV

      - name: Promote Package Version
        run: |
          echo "Promoting package version: ${{ env.PACKAGE_VERSION_ID }}"
          sf package version promote --package "${{ env.PACKAGE_VERSION_ID }}" --no-prompt

  # JOB 2: Deploys to Sandbox
  deploy_sandbox:
    runs-on: ubuntu-latest
    needs: build_and_promote # This job waits for Job 1 to finish
    
    steps:
      - name: Install Salesforce CLI
        uses: sfdx-actions/setup-sfdx@v1

      # This job authenticates to the SANDBOX org
      - name: Authenticate to Sandbox Org
        run: |
          echo "${{ secrets.SF_SANDBOX_AUTH_URL }}" > ./sandbox-auth.txt
          sf org login sfdx-url --sfdx-url-file ./sandbox-auth.txt --alias sandboxOrg

      - name: Install Package in Sandbox
        run: |
          # This 'needs' context gets the Package ID from Job 1
          PACKAGE_ID_FROM_BUILD="${{ needs.build_and_promote.outputs.package_version_id }}"
          echo "Installing package version: $PACKAGE_ID_FROM_BUILD into sandboxOrg"
          sf package install --package "$PACKAGE_ID_FROM_BUILD" --target-org sandboxOrg --installation-key "${{ secrets.PACKAGE_INSTALL_KEY }}" --wait 10 --publish-wait 10

  # JOB 3: Deploys to Production (with Approval)
  deploy_production:
    runs-on: ubuntu-latest
    needs: deploy_sandbox # This job waits for Job 2 to finish
    
    # This is the 'approval' part. It targets the environment you created.
    environment: 
      name: Production 
    
    steps:
      - name: Install Salesforce CLI
        uses: sfdx-actions/setup-sfdx@v1

      # This job authenticates to the PRODUCTION org
      - name: Authenticate to Production Org
        run: |
          echo "${{ secrets.SF_PROD_AUTH_URL }}" > ./prod-auth.txt
          sf org login sfdx-url --sfdx-url-file ./prod-auth.txt --alias prodOrg

      - name: Install Package in Production
        run: |
          # This 'needs' context also gets the Package ID from Job 1
          PACKAGE_ID_FROM_BUILD="${{ needs.build_and_promote.outputs.package_version_id }}"
          echo "Installing package version: $PACKAGE_ID_FROM_BUILD into prodOrg"
          sf package install --package "$PACKAGE_ID_FROM_BUILD" --target-org prodOrg --installation-key "${{ secrets.PACKAGE_INSTALL_KEY }}" --wait 10 --publish-wait 10